M公司IT开发部接到一个开发任务，想要对以前的一个系统开发一套界面皮肤库，可以对该桌面系统软件进行界面美化。这样，用户就可以在使用时通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框以及组合框等界面元素。该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员也可以在不修改既有代码的基础上增加新的皮肤。


抽象工厂与工厂方法最大的区别就在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级中的产品对象的创建。


主要优点
　　隔离了具体类的生成，使得客户并不需要知道什么被创建。因为这种隔离，因此更换一个具体工厂就变得相对容易。

　　当一个产品族中的多个对象被设计称一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。

　　增加新的产品族很方便，无需修改已有系统，符合开闭原则。

主要缺点
　　增加新的产品等级结构很麻烦，增加新的产品等级结构很麻烦，增加新的产品等级结构很麻烦！！！（重要的事情说三遍）因为需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这必然会带来较大的不便，在这个角度，它违背了开闭（对扩展开放，对修改封闭）原则。

　　想想，如果我们需要为单选按钮（RadioButton）提供不同皮肤的风格化显示，会发现无论选择哪种皮肤，单选按钮都显得“格格不入”。

应用场景
　　用户无须关心对象的创建过程，需要将对象的创建和使用解耦 -> 这是所有工厂模式的使用前提

　　系统中有多余一个的产品族，而每次都只使用其中的某一种产品族。 -> 可以通过配置文件等方式来使得用户可以动态地改变产品族，也可以很方便地增加新的产品族

　　产品等级结构稳定！设计完成之后，不会向系统中增加新的产品等级结构或删除已有产品等级结构。 -> 并不太符合开闭原则